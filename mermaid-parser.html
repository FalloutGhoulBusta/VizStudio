<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mermaid Diagram Renderer</title>
    <link rel="icon" type="image/x-icon" href="/favicon.ico">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Rubik+Doodle+Shadow&display=swap');

        .rubik-doodle-shadow-regular {
            font-family: "Rubik Doodle Shadow", system-ui;
            font-weight: 400;
            font-style: normal;
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(-45deg, #e73c7e, #2c3e50, #23d5ab, #f39c12, #9b59b6, #e67e22);
            background-size: 400% 400%;
            animation: gradient 8s ease infinite;
            min-height: 100vh;
            padding: 20px;
            /* Ensure the animation is visible and working */
            background-attachment: fixed;
            overflow-x: hidden;
        }

        @keyframes gradient {
            0% {
                background-position: 0% 50%;
            }
            20% {
                background-position: 100% 50%;
            }
            40% {
                background-position: 100% 100%;
            }
            60% {
                background-position: 0% 100%;
            }
            80% {
                background-position: 50% 0%;
            }
            100% {
                background-position: 0% 50%;
            }
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.15);
            overflow: hidden;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .header {
            background: linear-gradient(135deg, #2c3e50, #34495e);
            color: white;
            padding: 20px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
        }

        .header p {
            opacity: 0.9;
            font-size: 1.1rem;
        }

        .controls {
            padding: 20px;
            background: rgba(248, 249, 250, 0.9);
            border-bottom: 1px solid rgba(233, 236, 239, 0.8);
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            align-items: center;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        label {
            font-weight: 600;
            color: #495057;
        }

        select, button {
            padding: 8px 12px;
            border-radius: 5px;
            font-size: 14px;
        }

        select {
            border: 2px solid transparent;
            background: linear-gradient(rgba(255, 255, 255, 0.9), rgba(255, 255, 255, 0.9)) padding-box,
                        linear-gradient(135deg, #e73c7e, #9b59b6, #23d5ab) border-box;
            color: #2c3e50;
            transition: all 0.3s ease;
            font-weight: 500;
            box-shadow: 0 2px 8px rgba(231, 60, 126, 0.15);
            position: relative;
        }

        select:focus {
            outline: none;
            background: linear-gradient(white, white) padding-box,
                        linear-gradient(135deg, #e73c7e, #23d5ab) border-box;
            box-shadow: 0 0 0 3px rgba(231, 60, 126, 0.2),
                        0 4px 15px rgba(231, 60, 126, 0.25);
            transform: translateY(-1px);
        }

        select:hover {
            background: linear-gradient(white, white) padding-box,
                        linear-gradient(135deg, #23d5ab, #e73c7e, #9b59b6) border-box;
            box-shadow: 0 3px 12px rgba(231, 60, 126, 0.2);
            transform: translateY(-0.5px);
        }

        button {
            background: linear-gradient(135deg, #e73c7e, #9b59b6);
            color: white;
            cursor: pointer;
            transition: all 2.4s ease;
            border: none;
            box-shadow: 0 4px 15px rgba(231, 60, 126, 0.3);
            font-weight: 500;
        }

        button:hover {
            background: linear-gradient(135deg, #9b59b6, #e73c7e);
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(231, 60, 126, 0.4);
        }

        button:active {
            transform: translateY(0);
            box-shadow: 0 2px 10px rgba(231, 60, 126, 0.3);
        }

        /* Special styling for primary action buttons */
        button[onclick*="renderDiagram"] {
            background: linear-gradient(135deg, #f39c12, #e67e22);
            box-shadow: 0 4px 15px rgba(243, 156, 18, 0.3);
        }

        button[onclick*="renderDiagram"]:hover {
            background: linear-gradient(135deg, #e67e22, #f39c12);
            box-shadow: 0 6px 20px rgba(243, 156, 18, 0.4);
        }

        button[onclick*="download"] {
            background: linear-gradient(135deg, #23d5ab, #2c3e50);
            box-shadow: 0 4px 15px rgba(35, 213, 171, 0.3);
            transition: all 0.6s ease;
        }

        button[onclick*="download"]:hover {
            background: linear-gradient(135deg, #2c3e50, #23d5ab);
            box-shadow: 0 6px 20px rgba(35, 213, 171, 0.4);
        }

        /* Smaller buttons (editor and preview actions) */
        .editor-actions button,
        .preview-actions button {
            background: linear-gradient(135deg, #9b59b6, #e73c7e);
            font-size: 12px;
            padding: 5px 10px;
            box-shadow: 0 2px 8px rgba(155, 89, 182, 0.3);
            transition: all 0.4s ease;
            position: relative;
            overflow: hidden;
        }

        .editor-actions button:hover,
        .preview-actions button:hover {
            background: linear-gradient(135deg, #e73c7e, #9b59b6);
            box-shadow: 0 3px 12px rgba(155, 89, 182, 0.4);
            transform: translateY(-1px);
        }

        /* Enhanced button styles for specific functions */
        .editor-actions button[onclick="quickFixSyntax()"] {
            background: linear-gradient(135deg, #3498db, #2980b9);
            box-shadow: 0 2px 8px rgba(52, 152, 219, 0.3);
        }

        .editor-actions button[onclick="quickFixSyntax()"]:hover {
            background: linear-gradient(135deg, #2980b9, #1f4e79);
            box-shadow: 0 3px 12px rgba(52, 152, 219, 0.4);
        }

        #aiFixBtn {
            background: linear-gradient(135deg, #f39c12, #e67e22) !important;
            box-shadow: 0 2px 8px rgba(243, 156, 18, 0.3) !important;
        }

        #aiFixBtn:hover {
            background: linear-gradient(135deg, #e67e22, #d35400) !important;
            box-shadow: 0 3px 12px rgba(243, 156, 18, 0.4) !important;
        }

        .main-content {
            display: flex;
            height: calc(100vh - 200px);
            min-height: 600px;
        }

        .editor-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            border-right: 3px solid transparent;
            background: linear-gradient(white, white) padding-box,
                        linear-gradient(180deg, #e73c7e, #9b59b6, #23d5ab) border-box;
            position: relative;
        }

        .editor-panel::after {
            content: '';
            position: absolute;
            top: 0;
            right: -1px;
            width: 2px;
            height: 100%;
            background: linear-gradient(180deg, #e73c7e 0%, #9b59b6 50%, #23d5ab 100%);
            box-shadow: 0 0 10px rgba(231, 60, 126, 0.3);
            animation: borderGlow 4s ease-in-out infinite alternate;
        }

        @keyframes borderGlow {
            0% {
                box-shadow: 0 0 10px rgba(231, 60, 126, 0.3);
                opacity: 0.8;
            }
            100% {
                box-shadow: 0 0 20px rgba(231, 60, 126, 0.5), 0 0 30px rgba(155, 89, 182, 0.3);
                opacity: 1;
            }
        }

        .editor-header {
            background: rgba(248, 249, 250, 0.9);
            padding: 15px;
            border-bottom: 1px solid rgba(233, 236, 239, 0.8);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .editor-title {
            font-weight: 600;
            color: #495057;
        }

        .editor-actions {
            display: flex;
            gap: 10px;
        }

        .editor-actions button {
            padding: 5px 10px;
            font-size: 12px;
        }

        #mermaidInput {
            flex: 1;
            padding: 20px;
            border: none;
            outline: none;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.5;
            resize: none;
            background: rgba(248, 249, 250, 0.9);
        }

        .preview-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        .preview-header {
            background: rgba(248, 249, 250, 0.9);
            padding: 15px;
            border-bottom: 1px solid rgba(233, 236, 239, 0.8);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .preview-title {
            font-weight: 600;
            color: #495057;
        }

        .preview-actions {
            display: flex;
            gap: 10px;
        }

        .preview-actions button {
            padding: 5px 10px;
            font-size: 12px;
        }

        /* Reset button in preview header */
        .preview-actions .fit-btn {
            background: linear-gradient(135deg, #f39c12, #e67e22);
            color: white;
            border: none;
            border-radius: 5px;
            padding: 5px 12px;
            font-size: 12px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.4s ease;
            box-shadow: 0 2px 8px rgba(243, 156, 18, 0.3);
        }

        .preview-actions .fit-btn:hover {
            background: linear-gradient(135deg, #e67e22, #f39c12);
            transform: translateY(-1px);
            box-shadow: 0 3px 12px rgba(243, 156, 18, 0.4);
        }

        #diagramContainer {
            flex: 1;
            padding: 20px;
            overflow: hidden;
            background: white;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            cursor: grab;
        }

        /* Floating control panels */
        .floating-controls {
            position: absolute;
            z-index: 1000;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.15);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            padding: 8px;
            display: flex;
            gap: 4px;
        }



        .floating-controls.bottom-right {
            bottom: 15px;
            right: 15px;
            flex-direction: column;
            gap: 8px;
        }

        .floating-controls.bottom-left {
            bottom: 15px;
            left: 15px;
        }

        .control-row {
            display: flex;
            gap: 4px;
        }

        .floating-controls button {
            background: linear-gradient(135deg, #2c3e50, #34495e);
            color: white;
            border: none;
            width: 32px;
            height: 32px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            box-shadow: 0 2px 8px rgba(44, 62, 80, 0.3);
        }

        .floating-controls button:hover {
            background: linear-gradient(135deg, #34495e, #2c3e50);
            transform: translateY(-1px);
            box-shadow: 0 3px 12px rgba(44, 62, 80, 0.4);
        }

        .floating-controls button:active {
            transform: translateY(0);
            box-shadow: 0 1px 6px rgba(44, 62, 80, 0.3);
        }

        /* Special styling for zoom buttons */
        .floating-controls button.zoom-btn {
            background: linear-gradient(135deg, #23d5ab, #2c3e50);
        }

        .floating-controls button.zoom-btn:hover {
            background: linear-gradient(135deg, #2c3e50, #23d5ab);
        }

        /* Special styling for directional buttons */
        .floating-controls button.direction-btn {
            background: linear-gradient(135deg, #9b59b6, #e73c7e);
        }

        .floating-controls button.direction-btn:hover {
            background: linear-gradient(135deg, #e73c7e, #9b59b6);
        }



        #diagramContainer.panning {
            cursor: grabbing;
        }

        #mermaidDiagram {
            transition: transform 0.1s ease-out;
            user-select: none;
        }

        #mermaidDiagram.no-transition {
            transition: none;
        }

        .error-message {
            color: #2c3e50;
            background: linear-gradient(135deg, rgba(231, 60, 126, 0.1), rgba(243, 156, 18, 0.1));
            border: 2px solid rgba(231, 60, 126, 0.3);
            padding: 15px;
            border-radius: 8px;
            margin: 20px;
            backdrop-filter: blur(5px);
            box-shadow: 0 4px 15px rgba(231, 60, 126, 0.2);
        }

        .ai-loading {
            color: #2c3e50;
            background: linear-gradient(135deg, rgba(243, 156, 18, 0.1), rgba(35, 213, 171, 0.1));
            border: 2px solid rgba(243, 156, 18, 0.3);
            padding: 15px;
            border-radius: 8px;
            margin: 20px;
            backdrop-filter: blur(5px);
            box-shadow: 0 4px 15px rgba(243, 156, 18, 0.2);
            text-align: center;
        }

        .ai-success {
            color: #2c3e50;
            background: linear-gradient(135deg, rgba(35, 213, 171, 0.1), rgba(155, 89, 182, 0.1));
            border: 2px solid rgba(35, 213, 171, 0.3);
            padding: 15px;
            border-radius: 8px;
            margin: 20px;
            backdrop-filter: blur(5px);
            box-shadow: 0 4px 15px rgba(35, 213, 171, 0.2);
        }

        /* AI Fix button styling */
        #aiFixBtn {
            background: linear-gradient(135deg, #f39c12, #e67e22) !important;
            transition: all 0.4s ease !important;
        }

        #aiFixBtn:hover {
            background: linear-gradient(135deg, #e67e22, #f39c12) !important;
            transform: translateY(-1px);
            box-shadow: 0 3px 12px rgba(243, 156, 18, 0.4);
        }

        #apiKeyInput:focus {
            outline: none;
            background: linear-gradient(white, white) padding-box,
                        linear-gradient(135deg, #f39c12, #e67e22) border-box;
            box-shadow: 0 0 0 3px rgba(243, 156, 18, 0.2),
                        0 4px 15px rgba(243, 156, 18, 0.25);
            transform: translateY(-1px);
        }

        .examples {
            padding: 20px;
            background: rgba(248, 249, 250, 0.9);
            border-top: 1px solid rgba(233, 236, 239, 0.8);
        }

        .examples h3 {
            margin-bottom: 15px;
            color: #495057;
        }

        .footer {
            padding: 15px 20px;
            background: rgba(248, 249, 250, 0.95);
            border-top: 1px solid rgba(233, 236, 239, 0.8);
            text-align: center;
        }

        .footer p {
            margin: 0;
            color: #6c757d;
            font-size: 14px;
        }

        .footer em {
            color: #495057;
        }

        .example-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }

        .example-btn {
            background: linear-gradient(135deg, #2c3e50, #23d5ab);
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 13px;
            transition: all 0.6s ease;
            box-shadow: 0 3px 10px rgba(44, 62, 80, 0.3);
            font-weight: 500;
        }

        .example-btn:hover {
            background: linear-gradient(135deg, #23d5ab, #2c3e50);
            transform: translateY(-1px);
            box-shadow: 0 4px 15px rgba(44, 62, 80, 0.4);
        }

        .example-btn:active {
            transform: translateY(0);
            box-shadow: 0 2px 8px rgba(44, 62, 80, 0.3);
        }

        @media (max-width: 768px) {
            .main-content {
                flex-direction: column;
                height: auto;
            }

            .editor-panel {
                border-right: none;
                border-bottom: 3px solid transparent;
                background: linear-gradient(white, white) padding-box,
                            linear-gradient(90deg, #e73c7e, #9b59b6, #23d5ab) border-box;
            }

            .editor-panel::after {
                display: none;
            }

            .editor-panel::before {
                content: '';
                position: absolute;
                bottom: -1px;
                left: 0;
                width: 100%;
                height: 2px;
                background: linear-gradient(90deg, #e73c7e 0%, #9b59b6 50%, #23d5ab 100%);
                box-shadow: 0 0 10px rgba(231, 60, 126, 0.3);
                animation: borderGlow 4s ease-in-out infinite alternate;
            }

            #mermaidInput {
                min-height: 300px;
            }

            #diagramContainer {
                min-height: 400px;
            }

            /* Mobile adjustments for floating controls */
            .floating-controls {
                padding: 6px;
            }



            .floating-controls.bottom-right {
                bottom: 10px;
                right: 10px;
            }

            .floating-controls.bottom-left {
                bottom: 10px;
                left: 10px;
            }

            .floating-controls button {
                width: 28px;
                height: 28px;
                font-size: 12px;
            }



            /* Adjust spacers for mobile */
            .floating-controls .control-row div[style*="width: 32px"] {
                width: 28px !important;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1 class="rubik-doodle-shadow-regular">üßú‚Äç‚ôÄÔ∏è Mermaid Diagram Renderer</h1>
            <p>Create beautiful diagrams with Mermaid syntax</p>
        </div>

        <div class="controls">
            <div class="control-group">
                <label for="themeSelect">Theme:</label>
                <select id="themeSelect">
                    <option value="default">Default</option>
                    <option value="neutral">Neutral</option>
                    <option value="dark">Dark</option>
                    <option value="forest">Forest</option>
                    <option value="base">Base</option>
                </select>
            </div>

            <div class="control-group">
                <label for="directionSelect">Direction:</label>
                <select id="directionSelect">
                    <option value="TD">Top to Bottom</option>
                    <option value="BT">Bottom to Top</option>
                    <option value="LR">Left to Right</option>
                    <option value="RL">Right to Left</option>
                </select>
            </div>

            <div class="control-group">
                <label for="apiKeyInput">ü§ñ OpenRouter API Key:</label>
                <input type="password" id="apiKeyInput" placeholder="Enter your OpenRouter API key..." style="padding: 8px 12px; border-radius: 5px; border: 2px solid transparent; background: linear-gradient(rgba(255, 255, 255, 0.9), rgba(255, 255, 255, 0.9)) padding-box, linear-gradient(135deg, #e73c7e, #9b59b6, #23d5ab) border-box; color: #2c3e50; transition: all 0.3s ease; font-weight: 500; box-shadow: 0 2px 8px rgba(231, 60, 126, 0.15); width: 200px;">
            </div>

            <button onclick="renderDiagram()">üé® Render Diagram</button>
            <button onclick="downloadSVG()">üì• Download SVG</button>
            <button onclick="downloadPNG()">üì• Download PNG</button>
            <button onclick="downloadPNGFallback()" style="display: none;" id="pngFallbackBtn">üì• PNG (Fallback)</button>
        </div>

        <div class="main-content">
            <div class="editor-panel">
                <div class="editor-header">
                    <div class="editor-title">üìù Mermaid Code Editor</div>
                    <div class="editor-actions">
                        <button onclick="clearEditor()">Clear</button>
                        <button onclick="formatCode()">Format</button>
                        <button onclick="quickFixSyntax()" style="background: linear-gradient(135deg, #3498db, #2980b9);">‚ö° Quick Fix</button>
                        <button id="aiFixBtn" onclick="fixWithAI()" style="display: none; background: linear-gradient(135deg, #f39c12, #e67e22);">ü§ñ Fix with AI</button>
                    </div>
                </div>
                <textarea id="mermaidInput" placeholder="Enter your Mermaid diagram code here...">
graph TD
    A[Start] --> B{Is it working?}
    B -->|Yes| C[Great!]
    B -->|No| D[Fix it]
    D --> B
    C --> E[End]
                </textarea>
            </div>

            <div class="preview-panel">
                <div class="preview-header">
                    <div class="preview-title">üëÅÔ∏è Live Preview</div>
                    <div class="preview-actions">
                        <button class="fit-btn" onclick="resetView()" title="Reset View">üîÑ Reset</button>
                    </div>
                </div>
                <div id="diagramContainer">
                    <div id="mermaidDiagram"></div>

                    <!-- Bottom left controls: Zoom buttons -->
                    <div class="floating-controls bottom-left">
                        <button class="zoom-btn" onclick="zoomIn()" title="Zoom In">+</button>
                        <button class="zoom-btn" onclick="zoomOut()" title="Zoom Out">‚àí</button>
                    </div>

                    <!-- Bottom right controls: Directional arrows -->
                    <div class="floating-controls bottom-right">
                        <!-- Directional controls in keyboard arrow layout -->
                        <div class="control-row">
                            <div style="width: 32px;"></div> <!-- Spacer for left alignment -->
                            <button class="direction-btn" onclick="panUp()" title="Pan Up">‚Üë</button>
                            <div style="width: 32px;"></div> <!-- Spacer for right alignment -->
                        </div>
                        <div class="control-row">
                            <button class="direction-btn" onclick="panLeft()" title="Pan Left">‚Üê</button>
                            <button class="direction-btn" onclick="panDown()" title="Pan Down">‚Üì</button>
                            <button class="direction-btn" onclick="panRight()" title="Pan Right">‚Üí</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="examples">
            <h3 class="rubik-doodle-shadow-regular">üìö Quick Examples</h3>
            <div class="example-buttons">
                <button class="example-btn" onclick="loadExample('flowchart')">Flowchart</button>
                <button class="example-btn" onclick="loadExample('sequence')">Sequence Diagram</button>
                <button class="example-btn" onclick="loadExample('gantt')">Gantt Chart</button>
                <button class="example-btn" onclick="loadExample('pie')">Pie Chart</button>
                <button class="example-btn" onclick="loadExample('class')">Class Diagram</button>
                <button class="example-btn" onclick="loadExample('state')">State Diagram</button>
                <button class="example-btn" onclick="loadExample('er')">ER Diagram</button>
                <button class="example-btn" onclick="loadExample('journey')">User Journey</button>
            </div>
        </div>

        <!-- Footer with enhanced features info -->
        <div class="footer">
            <p><em>‚ö†Ô∏è Note: Free tier users are limited to 50 AI model requests per day. Use the AI Fix feature wisely!</em></p>
            <p><em>üöÄ Enhanced Features: ‚ö° Quick Fix (offline), ü§ñ AI Fix (structured outputs), üìä Smart caching, üîç Error analysis, üîÑ Fallback support</em></p>
        </div>
    </div>

    <script>
        // Initialize Mermaid
        mermaid.initialize({
            startOnLoad: false,
            theme: 'default',
            securityLevel: 'loose',
            flowchart: {
                useMaxWidth: true,
                htmlLabels: true
            }
        });

        let currentZoom = 1;
        let diagramCounter = 0;

        // Pan/drag variables
        let isPanning = false;
        let panX = 0;
        let panY = 0;
        let startX = 0;
        let startY = 0;
        let lastPanX = 0;
        let lastPanY = 0;

        // Scroll zoom variables
        let scrollTimeout = null;
        let isScrolling = false;

        // AI Editor variables
        let lastError = null;
        let isAIProcessing = false;

        // Enhanced AI features
        const fixCache = new Map();
        const MAX_CACHE_SIZE = 100;

        // **Enhanced Error Context Functions**
        function extractLineNumber(error) {
            if (!error || !error.message) return null;

            // Try to extract line number from common error patterns
            const linePatterns = [
                /line (\d+)/i,
                /at line (\d+)/i,
                /on line (\d+)/i,
                /\((\d+):\d+\)/,
                /Parse error on line (\d+)/i
            ];

            for (const pattern of linePatterns) {
                const match = error.message.match(pattern);
                if (match) {
                    return parseInt(match[1], 10);
                }
            }

            return null;
        }

        function detectDiagramType(code) {
            if (!code) return 'unknown';

            const trimmedCode = code.trim().toLowerCase();

            // Detect diagram type based on keywords
            if (trimmedCode.startsWith('graph') || trimmedCode.startsWith('flowchart')) {
                return 'flowchart';
            } else if (trimmedCode.startsWith('sequencediagram') || trimmedCode.includes('participant')) {
                return 'sequence';
            } else if (trimmedCode.startsWith('classDiagram') || trimmedCode.includes('class ')) {
                return 'class';
            } else if (trimmedCode.startsWith('stateDiagram') || trimmedCode.includes('state ')) {
                return 'state';
            } else if (trimmedCode.startsWith('erDiagram') || trimmedCode.includes('entity ')) {
                return 'er';
            } else if (trimmedCode.startsWith('journey')) {
                return 'journey';
            } else if (trimmedCode.startsWith('gantt')) {
                return 'gantt';
            } else if (trimmedCode.startsWith('pie')) {
                return 'pie';
            } else if (trimmedCode.startsWith('gitgraph') || trimmedCode.includes('commit')) {
                return 'gitgraph';
            }

            return 'unknown';
        }

        function analyzeCommonIssues(code) {
            if (!code) return [];

            const issues = [];
            const lines = code.split('\n');

            // Check for common syntax issues
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();
                const lineNum = i + 1;

                // Check for arrow syntax issues
                if (line.includes('--') && !line.includes('-->') && !line.includes('---')) {
                    issues.push({
                        line: lineNum,
                        issue: 'Incomplete arrow syntax',
                        suggestion: 'Use --> for arrows'
                    });
                }

                // Check for missing quotes in labels
                if (line.includes('[') && line.includes(']') && line.includes(' ') && !line.includes('"')) {
                    const bracketContent = line.match(/\[([^\]]+)\]/);
                    if (bracketContent && bracketContent[1].includes(' ')) {
                        issues.push({
                            line: lineNum,
                            issue: 'Spaces in labels should be quoted',
                            suggestion: 'Use quotes around labels with spaces'
                        });
                    }
                }

                // Check for semicolon instead of arrow
                if (line.includes(';') && !line.includes('-->')) {
                    issues.push({
                        line: lineNum,
                        issue: 'Semicolon found, might need arrow',
                        suggestion: 'Use --> to connect nodes'
                    });
                }
            }

            return issues;
        }

        function buildErrorContext(code, error) {
            return {
                originalCode: code,
                errorMessage: error?.message || 'Unknown error',
                errorLine: extractLineNumber(error),
                diagramType: detectDiagramType(code),
                commonPatterns: analyzeCommonIssues(code),
                codeLength: code?.length || 0,
                lineCount: code?.split('\n').length || 0
            };
        }

        // **Progressive Enhancement - Offline Syntax Validation**
        function validateMermaidSyntax(code) {
            if (!code) return code;

            const commonErrors = [
                // Arrow syntax fixes
                { pattern: /\-\-(?!\>|\-)/g, fix: '-->' },
                { pattern: /\s+\-\-\s+/g, fix: ' --> ' },
                { pattern: /\-\>\-/g, fix: '-->' },

                // Bracket and parentheses fixes
                { pattern: /\[\s+/g, fix: '[' },
                { pattern: /\s+\]/g, fix: ']' },
                { pattern: /\(\s+/g, fix: '(' },
                { pattern: /\s+\)/g, fix: ')' },

                // Quote fixes for labels with spaces
                { pattern: /\[([^"\]]*\s[^"\]]*)\]/g, fix: '["$1"]' },

                // Common typos
                { pattern: /flowchar\b/gi, fix: 'flowchart' },
                { pattern: /grap\b/gi, fix: 'graph' },
                { pattern: /sequenceDiagra\b/gi, fix: 'sequenceDiagram' },

                // Semicolon to arrow conversion
                { pattern: /;\s*$/gm, fix: '' },
                { pattern: /([A-Za-z0-9_]+)\s*;\s*([A-Za-z0-9_]+)/g, fix: '$1 --> $2' },

                // Remove extra whitespace
                { pattern: /\s+$/gm, fix: '' },
                { pattern: /^\s+/gm, fix: '' },
                { pattern: /\n\s*\n\s*\n/g, fix: '\n\n' }
            ];

            let fixedCode = code;
            let appliedFixes = [];

            commonErrors.forEach((rule, index) => {
                const beforeFix = fixedCode;
                fixedCode = fixedCode.replace(rule.pattern, rule.fix);
                if (beforeFix !== fixedCode) {
                    appliedFixes.push(`Fix ${index + 1}: Applied pattern correction`);
                }
            });

            // Log applied fixes for debugging
            if (appliedFixes.length > 0) {
                console.log('Offline syntax fixes applied:', appliedFixes);
            }

            return fixedCode;
        }

        // **Cache Management Functions**
        function hashCode(str) {
            let hash = 0;
            if (str.length === 0) return hash;
            for (let i = 0; i < str.length; i++) {
                const char = str.charCodeAt(i);
                hash = ((hash << 5) - hash) + char;
                hash = hash & hash; // Convert to 32-bit integer
            }
            return hash.toString();
        }

        function cleanupCache() {
            if (fixCache.size > MAX_CACHE_SIZE) {
                // Remove oldest entries (simple FIFO)
                const keysToDelete = Array.from(fixCache.keys()).slice(0, fixCache.size - MAX_CACHE_SIZE + 10);
                keysToDelete.forEach(key => fixCache.delete(key));
                console.log(`Cache cleanup: Removed ${keysToDelete.length} old entries`);
            }
        }

        function getCacheStats() {
            return {
                size: fixCache.size,
                maxSize: MAX_CACHE_SIZE,
                hitRate: fixCache.hitCount || 0,
                missCount: fixCache.missCount || 0
            };
        }

        // **Quick Fix Function - Offline Syntax Validation**
        function quickFixSyntax() {
            const currentCode = document.getElementById('mermaidInput').value;
            if (!currentCode.trim()) {
                alert('Please enter some Mermaid code first.');
                return;
            }

            const originalCode = currentCode;
            const fixedCode = validateMermaidSyntax(currentCode);

            if (fixedCode !== originalCode) {
                // Apply the fixed code
                document.getElementById('mermaidInput').value = fixedCode;

                // Log success message to console
                console.log('‚ö° Quick fixes applied - Common syntax issues have been automatically corrected');

                // Render the fixed diagram
                renderDiagram();
            } else {
                // No fixes needed - log to console
                console.log('‚úÖ No common syntax issues found - Code looks good');

                renderDiagram();
            }
        }

        // **Enhanced Format Function**
        function formatCode() {
            const textarea = document.getElementById('mermaidInput');
            let code = textarea.value;

            if (!code.trim()) {
                alert('Please enter some Mermaid code first.');
                return;
            }

            // Apply basic formatting
            const lines = code.split('\n');
            const formattedLines = [];
            let indentLevel = 0;

            for (let line of lines) {
                const trimmedLine = line.trim();
                if (!trimmedLine) {
                    formattedLines.push('');
                    continue;
                }

                // Decrease indent for closing braces or end statements
                if (trimmedLine.includes('}') || trimmedLine.startsWith('end')) {
                    indentLevel = Math.max(0, indentLevel - 1);
                }

                // Add proper indentation
                const indent = '    '.repeat(indentLevel);
                formattedLines.push(indent + trimmedLine);

                // Increase indent for opening braces or subgraph statements
                if (trimmedLine.includes('{') || trimmedLine.startsWith('subgraph')) {
                    indentLevel++;
                }
            }

            // Apply quick fixes as well
            const formattedCode = validateMermaidSyntax(formattedLines.join('\n'));
            textarea.value = formattedCode;

            // Re-render the diagram
            renderDiagram();
        }

        // **Example templates for different diagram types**
        const examples = {
            flowchart: `graph TD
    A[Start] --> B{Decision}
    B -->|Yes| C[Process 1]
    B -->|No| D[Process 2]
    C --> E[End]
    D --> E`,

            sequence: `sequenceDiagram
    participant Alice
    participant Bob
    Alice->>John: Hello John, how are you?
    loop Healthcheck
        John->>John: Fight against hypochondria
    end
    Note right of John: Rational thoughts
    John-->>Alice: Great!
    John->>Bob: How about you?
    Bob-->>John: Jolly good!`,

            gantt: `gantt
    title A Gantt Diagram
    dateFormat  YYYY-MM-DD
    section Section
    A task           :a1, 2014-01-01, 30d
    Another task     :after a1  , 20d
    section Another
    Task in sec      :2014-01-12  , 12d
    another task      : 24d`,

            pie: `pie title Pet Ownership
    "Dogs" : 386
    "Cats" : 85
    "Birds" : 15
    "Fish" : 25`,

            class: `classDiagram
    class Animal{
        +String name
        +int age
        +makeSound()
    }
    class Dog{
        +String breed
        +bark()
    }
    class Cat{
        +String color
        +meow()
    }
    Animal <|-- Dog
    Animal <|-- Cat`,

            state: `stateDiagram-v2
    [*] --> Still
    Still --> [*]
    Still --> Moving
    Moving --> Still
    Moving --> Crash
    Crash --> [*]`,

            er: `erDiagram
    CUSTOMER ||--o{ ORDER : places
    ORDER ||--|{ LINE-ITEM : contains
    CUSTOMER }|..|{ DELIVERY-ADDRESS : uses
    ORDER {
        int orderNumber
        date orderDate
    }
    CUSTOMER {
        string name
        string custNumber
    }`,

            journey: `journey
    title My working day
    section Go to work
      Make tea: 5: Me
      Go upstairs: 3: Me
      Do work: 1: Me, Cat
    section Go home
      Go downstairs: 5: Me
      Sit down: 5: Me`
        };

        // **Render the diagram**
        async function renderDiagram() {
            const input = document.getElementById('mermaidInput').value;
            const container = document.getElementById('diagramContainer');
            let diagramDiv = document.getElementById('mermaidDiagram');

            // Ensure container exists
            if (!container) {
                console.error('Diagram container not found');
                return;
            }

            // Ensure diagram div exists
            if (!diagramDiv) {
                console.log('Creating missing mermaidDiagram element');
                diagramDiv = document.createElement('div');
                diagramDiv.id = 'mermaidDiagram';
                diagramDiv.className = 'mermaid-diagram';
                container.appendChild(diagramDiv);
            }

            if (!input.trim()) {
                container.innerHTML = '<div class="error-message">Please enter some Mermaid code to render.</div>';
                return;
            }

            try {
                // Clear previous diagram
                diagramDiv.innerHTML = '';
                
                // Generate unique ID for this diagram
                const diagramId = `mermaid-${++diagramCounter}`;
                
                // Render the diagram
                const { svg } = await mermaid.render(diagramId, input);
                diagramDiv.innerHTML = svg;
                
                // Apply zoom
                applyZoom();
                
                // Remove any error messages and hide AI fix button
                const errorMsg = container.querySelector('.error-message');
                if (errorMsg) {
                    errorMsg.remove();
                }
                hideAIFixButton();

            } catch (error) {
                console.error('Mermaid rendering error:', error);
                lastError = error;
                container.innerHTML = `<div class="error-message">
                    <strong>Error rendering diagram:</strong><br>
                    ${error.message || 'Invalid Mermaid syntax'}
                </div>`;
                showAIFixButton();
            }
        }

        // **Load example diagrams**
        function loadExample(type) {
            if (examples[type]) {
                document.getElementById('mermaidInput').value = examples[type];
                renderDiagram();
            }
        }

        // **Theme change handler**
        document.getElementById('themeSelect').addEventListener('change', function() {
            mermaid.initialize({
                startOnLoad: false,
                theme: this.value,
                securityLevel: 'loose',
                flowchart: {
                    useMaxWidth: true,
                    htmlLabels: true
                }
            });
            renderDiagram();
        });

        // **Direction change handler**
        document.getElementById('directionSelect').addEventListener('change', function() {
            const input = document.getElementById('mermaidInput');
            let code = input.value;
            
            // Update direction for flowcharts
            if (code.includes('graph ')) {
                code = code.replace(/graph\s+[A-Z]{2}/, `graph ${this.value}`);
                input.value = code;
                renderDiagram();
            }
        });

        // **Zoom functions**
        function zoomIn() {
            currentZoom = Math.min(currentZoom + 0.2, 3);
            applyZoom();
        }

        function zoomOut() {
            currentZoom = Math.max(currentZoom - 0.2, 0.3);
            applyZoom();
        }

        function resetZoom() {
            currentZoom = 1;
            applyZoom();
        }

        function applyZoom() {
            const diagramDiv = document.getElementById('mermaidDiagram');
            if (diagramDiv) {
                diagramDiv.style.transform = `translate(${panX}px, ${panY}px) scale(${currentZoom})`;
                diagramDiv.style.transformOrigin = 'center center';
            }
        }

        // **Pan functions**
        function resetPan() {
            panX = 0;
            panY = 0;
            lastPanX = 0;
            lastPanY = 0;
            applyZoom();
        }

        // **Reset view function (combines reset zoom and pan)**
        function resetView() {
            currentZoom = 1;
            panX = 0;
            panY = 0;
            lastPanX = 0;
            lastPanY = 0;
            applyZoom();
        }

        function constrainPan() {
            const container = document.getElementById('diagramContainer');
            const diagramDiv = document.getElementById('mermaidDiagram');

            if (!container || !diagramDiv) return;

            const containerRect = container.getBoundingClientRect();
            const svgElement = diagramDiv.querySelector('svg');

            if (!svgElement) return;

            // Get the actual SVG dimensions
            const svgRect = svgElement.getBoundingClientRect();
            const svgWidth = svgRect.width * currentZoom;
            const svgHeight = svgRect.height * currentZoom;

            // Calculate container dimensions (excluding padding)
            const containerWidth = containerRect.width - 40; // Account for padding
            const containerHeight = containerRect.height - 40;

            // Calculate maximum pan values to keep diagram partially visible
            // Allow more generous bounds for better user experience
            const maxPanX = Math.max(50, (svgWidth - containerWidth) / 2 + 150);
            const maxPanY = Math.max(50, (svgHeight - containerHeight) / 2 + 150);

            // Constrain pan values
            panX = Math.max(-maxPanX, Math.min(maxPanX, panX));
            panY = Math.max(-maxPanY, Math.min(maxPanY, panY));
        }

        // **Directional pan functions**
        function panLeft() {
            panX -= 50;
            constrainPan();
            applyZoom();
        }

        function panRight() {
            panX += 50;
            constrainPan();
            applyZoom();
        }

        function panUp() {
            panY -= 50;
            constrainPan();
            applyZoom();
        }

        function panDown() {
            panY += 50;
            constrainPan();
            applyZoom();
        }

        // **Editor functions**
        function clearEditor() {
            document.getElementById('mermaidInput').value = '';
            document.getElementById('diagramContainer').innerHTML = '<div id="mermaidDiagram"></div>';
        }

        function formatCode() {
            const input = document.getElementById('mermaidInput');
            let code = input.value;

            // Basic formatting - add proper indentation
            const lines = code.split('\n');
            let formatted = [];
            let indentLevel = 0;

            for (let line of lines) {
                const trimmed = line.trim();
                if (!trimmed) {
                    formatted.push('');
                    continue;
                }

                // Decrease indent for closing brackets or end statements
                if (trimmed.includes('}') || trimmed.includes('end')) {
                    indentLevel = Math.max(0, indentLevel - 1);
                }

                // Add indentation
                formatted.push('    '.repeat(indentLevel) + trimmed);

                // Increase indent for opening brackets or certain keywords
                if (trimmed.includes('{') ||
                    trimmed.includes('subgraph') ||
                    trimmed.includes('section') ||
                    trimmed.includes('loop') ||
                    trimmed.includes('alt') ||
                    trimmed.includes('opt')) {
                    indentLevel++;
                }
            }

            input.value = formatted.join('\n');
        }

        // **AI Editor Functions**
        function showAIFixButton() {
            const aiFixBtn = document.getElementById('aiFixBtn');
            if (aiFixBtn) {
                aiFixBtn.style.display = 'inline-block';
            }
        }

        function hideAIFixButton() {
            const aiFixBtn = document.getElementById('aiFixBtn');
            if (aiFixBtn) {
                aiFixBtn.style.display = 'none';
            }
        }

        async function fixWithAI() {
            const apiKey = document.getElementById('apiKeyInput').value.trim();
            if (!apiKey) {
                alert('Please enter your OpenRouter API key first.');
                return;
            }

            if (!lastError) {
                alert('No error to fix. Please try rendering your diagram first.');
                return;
            }

            if (isAIProcessing) {
                return; // Prevent multiple simultaneous requests
            }

            isAIProcessing = true;
            const container = document.getElementById('diagramContainer');
            const currentCode = document.getElementById('mermaidInput').value;

            // **Enhanced Error Context & Caching**
            const errorContext = buildErrorContext(currentCode, lastError);
            const cacheKey = hashCode(currentCode + lastError?.message + errorContext.diagramType);

            // Check cache first
            if (fixCache.has(cacheKey)) {
                console.log('Cache hit: Using cached AI fix');
                fixCache.hitCount = (fixCache.hitCount || 0) + 1;

                const cachedFix = fixCache.get(cacheKey);
                document.getElementById('mermaidInput').value = cachedFix;

                console.log('‚úÖ Applied cached AI fix - Using previously generated solution');

                hideAIFixButton();
                renderDiagram();
                isAIProcessing = false;
                return;
            }

            fixCache.missCount = (fixCache.missCount || 0) + 1;

            // Show enhanced loading message with context
            container.innerHTML = `<div class="ai-loading">
                <strong>ü§ñ AI is analyzing your ${errorContext.diagramType} diagram...</strong><br>
                ${errorContext.errorLine ? `Focusing on line ${errorContext.errorLine} ‚Ä¢ ` : ''}
                ${errorContext.commonPatterns.length > 0 ? `Found ${errorContext.commonPatterns.length} potential issues ‚Ä¢ ` : ''}
                Please wait while we fix the Mermaid syntax errors.
            </div>`;

            try {
                // **Enhanced AI Prompt with Structured Output Context**
                const systemPrompt = `You are an expert Mermaid diagram syntax corrector. Your response must be a complete, valid JSON object with exactly these fields:

{
  "fixed_code": "corrected mermaid code here",
  "changes_made": ["list", "of", "changes"],
  "confidence": 85
}

CRITICAL REQUIREMENTS:
- Return ONLY the JSON object, nothing else
- Ensure the JSON is complete and properly closed with }
- Do not include markdown formatting or explanations
- The fixed_code should be valid Mermaid syntax for ${errorContext.diagramType} diagrams
- Confidence should be a number between 0-100

Context: Error on line ${errorContext.errorLine || 'unknown'}, ${errorContext.commonPatterns.length} issues detected.`;

                const userPrompt = `Fix this Mermaid diagram code that has syntax errors:

Error: ${errorContext.errorMessage}
${errorContext.errorLine ? `Error appears around line: ${errorContext.errorLine}` : ''}

${errorContext.commonPatterns.length > 0 ? `
Detected issues:
${errorContext.commonPatterns.map(issue => `- Line ${issue.line}: ${issue.issue} (${issue.suggestion})`).join('\n')}
` : ''}

Code to fix:
${currentCode}`;

                // **Try simple approach first - Llama models work better without structured outputs**
                console.log('Attempting AI fix with simplified approach...');

                const simpleSystemPrompt = `You are an expert Mermaid diagram syntax corrector. Fix the provided Mermaid code and return ONLY the corrected code without any explanations or formatting.`;

                const simpleUserPrompt = `Fix this broken Mermaid code:

Error: ${errorContext.errorMessage}
${errorContext.errorLine ? `Error on line: ${errorContext.errorLine}` : ''}

Code to fix:
${currentCode}

Return only the corrected Mermaid code:`;

                const response = await fetch('https://openrouter.ai/api/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${apiKey}`,
                        'Content-Type': 'application/json',
                        'HTTP-Referer': window.location.href,
                        'X-Title': 'Mermaid Diagram Renderer'
                    },
                    body: JSON.stringify({
                        model: 'meta-llama/llama-4-maverick-17b-128e-instruct:free',
                        messages: [
                            {
                                role: 'system',
                                content: simpleSystemPrompt
                            },
                            {
                                role: 'user',
                                content: simpleUserPrompt
                            }
                        ],
                        max_tokens: 1000,
                        temperature: 0.1
                        // **Removed structured outputs - they don't work well with this model**
                    })
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('OpenRouter API Error Details:', errorText);
                    throw new Error(`OpenRouter API error: ${response.status} ${response.statusText} - ${errorText}`);
                }

                const data = await response.json();
                console.log('OpenRouter Response:', data);

                // Check if the response has the expected structure
                if (!data.choices || !data.choices[0] || !data.choices[0].message) {
                    console.error('Unexpected response structure:', data);
                    throw new Error('Invalid response structure from OpenRouter API');
                }

                // **Parse Simple Text Response**
                const responseContent = data.choices[0].message.content;

                // Check if we got any content at all
                if (!responseContent || responseContent.trim() === '') {
                    console.error('Empty response from AI model');
                    throw new Error('AI model returned empty response. This may be due to content filtering or model limitations.');
                }

                console.log('AI Response Content:', responseContent);
                console.log('Response length:', responseContent.length);
                console.log('Response type:', typeof responseContent);

                // Clean up the response - remove any markdown formatting or extra text
                let cleanedCode = responseContent.trim();

                // Remove markdown code blocks if present
                if (cleanedCode.startsWith('```')) {
                    cleanedCode = cleanedCode.replace(/^```[\w]*\n?/, '').replace(/\n?```$/, '');
                }

                // Remove any explanatory text before or after the code
                const lines = cleanedCode.split('\n');
                let startIndex = 0;
                let endIndex = lines.length - 1;

                // Find the start of actual Mermaid code
                for (let i = 0; i < lines.length; i++) {
                    const line = lines[i].trim();
                    if (line.match(/^(graph|flowchart|sequenceDiagram|classDiagram|stateDiagram|erDiagram|journey|gitgraph|pie|gantt|mindmap|timeline|sankey|block)/)) {
                        startIndex = i;
                        break;
                    }
                }

                // Find the end of Mermaid code (stop at explanatory text)
                for (let i = lines.length - 1; i >= startIndex; i--) {
                    const line = lines[i].trim();
                    if (line && !line.toLowerCase().includes('explanation') && !line.toLowerCase().includes('note:') && !line.toLowerCase().includes('fixed:')) {
                        endIndex = i;
                        break;
                    }
                }

                const extractedCode = lines.slice(startIndex, endIndex + 1).join('\n').trim();

                // Create response object
                const aiResponse = {
                    fixed_code: extractedCode,
                    changes_made: ['AI syntax corrections applied'],
                    confidence: 85
                };

                const fixedCode = aiResponse.fixed_code;
                const changesMade = aiResponse.changes_made || [];
                const confidence = aiResponse.confidence || 85;

                // **Cache the AI response for future use**
                fixCache.set(cacheKey, fixedCode);
                cleanupCache(); // Manage cache size

                // Apply the fixed code
                document.getElementById('mermaidInput').value = fixedCode;

                // Log success details to console
                console.log(`‚úÖ AI has fixed your ${errorContext.diagramType} diagram!`);
                if (errorContext.commonPatterns.length > 0) {
                    console.log(`Resolved ${errorContext.commonPatterns.length} detected issues`);
                }
                console.log(`Confidence: ${confidence}% ‚Ä¢ Changes: ${changesMade.length}`);
                if (changesMade.length > 0) {
                    console.log('Changes made:', changesMade.slice(0, 3).join(', ') + (changesMade.length > 3 ? '...' : ''));
                }

                // Hide the AI fix button
                hideAIFixButton();

                // Render the fixed diagram
                renderDiagram();

            } catch (error) {
                console.error('AI fix error:', error);

                container.innerHTML = `<div class="error-message">
                    <strong>‚ùå AI Fix Failed:</strong><br>
                    ${error.message}<br><br>
                    Please check your API key and try again, or fix the code manually.
                </div>`;
                showAIFixButton(); // Show the button again for retry
            } finally {
                isAIProcessing = false;
            }
        }

        // **Download functions**
        function downloadSVG() {
            const svgElement = document.querySelector('#mermaidDiagram svg');
            if (!svgElement) {
                alert('Please render a diagram first before downloading.');
                return;
            }

            // Clone the SVG to avoid modifying the original
            const svgClone = svgElement.cloneNode(true);

            // Add XML declaration and namespace
            const svgString = new XMLSerializer().serializeToString(svgClone);
            const fullSvg = '<?xml version="1.0" encoding="UTF-8"?>\n' + svgString;

            // Create download link
            const blob = new Blob([fullSvg], { type: 'image/svg+xml' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = 'mermaid-diagram.svg';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
        }

        function downloadPNG() {
            console.log('PNG download initiated...');
            const svgElement = document.querySelector('#mermaidDiagram svg');
            if (!svgElement) {
                alert('Please render a diagram first before downloading.');
                return;
            }

            console.log('SVG element found:', svgElement);
            try {
                // Create a canvas element
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');

                // Get SVG dimensions - improved dimension detection
                const svgRect = svgElement.getBoundingClientRect();
                let svgWidth, svgHeight;

                if (svgElement.viewBox && svgElement.viewBox.baseVal) {
                    svgWidth = svgElement.viewBox.baseVal.width;
                    svgHeight = svgElement.viewBox.baseVal.height;
                } else if (svgElement.width && svgElement.height) {
                    svgWidth = parseFloat(svgElement.width.baseVal.value);
                    svgHeight = parseFloat(svgElement.height.baseVal.value);
                } else {
                    svgWidth = svgRect.width || 800;
                    svgHeight = svgRect.height || 600;
                }

                // Set canvas size with higher resolution for better quality
                const scale = 2;
                canvas.width = svgWidth * scale;
                canvas.height = svgHeight * scale;
                ctx.scale(scale, scale);

                // Clone and prepare SVG for conversion
                const svgClone = svgElement.cloneNode(true);

                // Ensure proper SVG attributes
                svgClone.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
                svgClone.setAttribute('xmlns:xlink', 'http://www.w3.org/1999/xlink');
                svgClone.setAttribute('width', svgWidth);
                svgClone.setAttribute('height', svgHeight);

                // Fix any missing viewBox
                if (!svgClone.getAttribute('viewBox')) {
                    svgClone.setAttribute('viewBox', `0 0 ${svgWidth} ${svgHeight}`);
                }

                // Get all computed styles and inline them
                const allElements = svgClone.querySelectorAll('*');
                allElements.forEach(element => {
                    const computedStyle = window.getComputedStyle(element);
                    let styleStr = '';

                    // Copy important style properties
                    const importantProps = [
                        'fill', 'stroke', 'stroke-width', 'stroke-dasharray', 'stroke-linecap',
                        'stroke-linejoin', 'opacity', 'font-family', 'font-size', 'font-weight',
                        'text-anchor', 'dominant-baseline', 'alignment-baseline'
                    ];

                    importantProps.forEach(prop => {
                        const value = computedStyle.getPropertyValue(prop);
                        if (value && value !== 'none' && value !== 'normal') {
                            styleStr += `${prop}: ${value}; `;
                        }
                    });

                    if (styleStr) {
                        const existingStyle = element.getAttribute('style') || '';
                        element.setAttribute('style', existingStyle + styleStr);
                    }
                });

                // Convert SVG to string with proper XML declaration
                const svgString = new XMLSerializer().serializeToString(svgClone);
                const fullSvgString = `<?xml version="1.0" encoding="UTF-8"?>
${svgString}`;

                // Create data URL directly instead of blob URL for better compatibility
                const svgDataUrl = 'data:image/svg+xml;charset=utf-8,' + encodeURIComponent(fullSvgString);

                // Create image and draw to canvas
                const img = new Image();
                img.onload = function() {
                    try {
                        // Fill white background
                        ctx.fillStyle = 'white';
                        ctx.fillRect(0, 0, svgWidth, svgHeight);

                        // Draw the SVG
                        ctx.drawImage(img, 0, 0, svgWidth, svgHeight);

                        // Download the PNG
                        canvas.toBlob(function(blob) {
                            if (blob) {
                                const url = URL.createObjectURL(blob);
                                const link = document.createElement('a');
                                link.href = url;
                                link.download = 'mermaid-diagram.png';
                                document.body.appendChild(link);
                                link.click();
                                document.body.removeChild(link);
                                URL.revokeObjectURL(url);
                            } else {
                                throw new Error('Failed to create PNG blob');
                            }
                        }, 'image/png', 0.95);
                    } catch (error) {
                        console.error('Error during canvas operations:', error);
                        alert('Error converting diagram to PNG. The diagram may contain unsupported elements. Please try downloading as SVG instead.');
                    }
                };

                img.onerror = function(error) {
                    console.error('Error loading SVG as image:', error);
                    console.log('SVG Data URL length:', svgDataUrl.length);
                    console.log('SVG Data URL preview:', svgDataUrl.substring(0, 200) + '...');
                    alert('Error converting diagram to PNG. This may be due to browser security restrictions or unsupported SVG elements. Showing fallback option...');
                    // Show fallback button
                    document.getElementById('pngFallbackBtn').style.display = 'inline-block';
                };

                // Set a timeout to catch hanging image loads
                const timeout = setTimeout(() => {
                    console.error('PNG conversion timed out');
                    alert('PNG conversion timed out. Please try downloading as SVG instead.');
                }, 10000);

                img.onload = (function(originalOnload) {
                    return function() {
                        clearTimeout(timeout);
                        originalOnload.call(this);
                    };
                })(img.onload);

                img.onerror = (function(originalOnerror) {
                    return function(error) {
                        clearTimeout(timeout);
                        originalOnerror.call(this, error);
                    };
                })(img.onerror);

                img.src = svgDataUrl;

            } catch (error) {
                console.error('Error in downloadPNG function:', error);
                alert('Error preparing diagram for PNG download. Showing fallback option...');
                // Show fallback button
                document.getElementById('pngFallbackBtn').style.display = 'inline-block';
            }
        }

        // Fallback PNG download using html2canvas-like approach
        function downloadPNGFallback() {
            const svgElement = document.querySelector('#mermaidDiagram svg');
            if (!svgElement) {
                alert('Please render a diagram first before downloading.');
                return;
            }

            try {
                // Create a new window/iframe approach for PNG conversion
                const svgData = new XMLSerializer().serializeToString(svgElement);

                // Get dimensions
                const svgRect = svgElement.getBoundingClientRect();
                const width = svgRect.width || 800;
                const height = svgRect.height || 600;

                // Create a temporary canvas
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                canvas.width = width * 2; // Higher resolution
                canvas.height = height * 2;
                ctx.scale(2, 2);

                // Fill white background
                ctx.fillStyle = 'white';
                ctx.fillRect(0, 0, width, height);

                // Create SVG data URL with embedded styles
                const svgWithStyles = `
                    <svg xmlns="http://www.w3.org/2000/svg" width="${width}" height="${height}" viewBox="0 0 ${width} ${height}">
                        <style>
                            .node rect, .node circle, .node ellipse, .node polygon, .node path { fill: #ECECFF; stroke: #9370DB; stroke-width: 1px; }
                            .node text { font-family: "trebuchet ms", verdana, arial, sans-serif; font-size: 14px; }
                            .edgePath path { stroke: #333; stroke-width: 1.5px; fill: none; }
                            .edgeLabel { background-color: #e8e8e8; text-align: center; }
                            .cluster rect { fill: #ffffde; stroke: #aaaa33; stroke-width: 1px; }
                            .cluster text { fill: #333; }
                        </style>
                        ${svgData.replace(/<svg[^>]*>/, '').replace(/<\/svg>$/, '')}
                    </svg>
                `;

                const img = new Image();
                img.onload = function() {
                    ctx.drawImage(img, 0, 0, width, height);

                    // Convert to blob and download
                    canvas.toBlob(function(blob) {
                        const url = URL.createObjectURL(blob);
                        const link = document.createElement('a');
                        link.href = url;
                        link.download = 'mermaid-diagram-fallback.png';
                        document.body.appendChild(link);
                        link.click();
                        document.body.removeChild(link);
                        URL.revokeObjectURL(url);

                        // Hide fallback button after successful download
                        document.getElementById('pngFallbackBtn').style.display = 'none';
                    }, 'image/png');
                };

                img.onerror = function() {
                    alert('Fallback PNG conversion also failed. Please download as SVG and convert manually.');
                };

                const svgBlob = new Blob([svgWithStyles], { type: 'image/svg+xml;charset=utf-8' });
                img.src = URL.createObjectURL(svgBlob);

            } catch (error) {
                console.error('Fallback PNG conversion error:', error);
                alert('All PNG conversion methods failed. Please download as SVG.');
            }
        }

        // **Pan/Drag Event Handlers**
        const diagramContainer = document.getElementById('diagramContainer');

        // Scroll to zoom functionality
        diagramContainer.addEventListener('wheel', function(e) {
            // Prevent default scrolling behavior
            e.preventDefault();

            // Don't zoom if interacting with buttons or interactive elements
            if (e.target.closest('button, [onclick], a')) {
                return;
            }

            // Clear any existing timeout
            if (scrollTimeout) {
                clearTimeout(scrollTimeout);
            }

            // Set scrolling state
            if (!isScrolling) {
                isScrolling = true;
                // Temporarily disable transitions for smoother scrolling
                const diagramDiv = document.getElementById('mermaidDiagram');
                if (diagramDiv) {
                    diagramDiv.style.transition = 'none';
                }
            }

            // Get the mouse position relative to the container
            const rect = diagramContainer.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;

            // Calculate zoom direction and amount
            const zoomDirection = e.deltaY > 0 ? -1 : 1; // Negative deltaY = zoom in, positive = zoom out

            // Use smaller zoom factor for smoother experience
            let zoomFactor = 0.05; // Reduced from 0.1 for smoother increments

            // Adjust zoom factor based on current zoom level for more natural feel
            if (currentZoom < 0.5) {
                zoomFactor = 0.03; // Slower when zoomed out
            } else if (currentZoom > 2) {
                zoomFactor = 0.08; // Faster when zoomed in
            }

            const oldZoom = currentZoom;

            // Apply zoom with limits
            if (zoomDirection > 0) {
                currentZoom = Math.min(currentZoom + zoomFactor, 3); // Max zoom 3x
            } else {
                currentZoom = Math.max(currentZoom - zoomFactor, 0.3); // Min zoom 0.3x
            }

            // Only proceed if zoom actually changed
            if (currentZoom !== oldZoom) {
                // Calculate zoom ratio for position adjustment
                const zoomRatio = currentZoom / oldZoom;

                // Adjust pan position to zoom towards mouse cursor
                // This keeps the point under the mouse cursor stationary during zoom
                panX = mouseX - (mouseX - panX) * zoomRatio;
                panY = mouseY - (mouseY - panY) * zoomRatio;

                // Constrain pan to keep diagram visible
                constrainPan();

                // Apply the zoom and pan
                applyZoom();
            }

            // Set timeout to re-enable transitions after scrolling stops
            scrollTimeout = setTimeout(() => {
                isScrolling = false;
                const diagramDiv = document.getElementById('mermaidDiagram');
                if (diagramDiv) {
                    diagramDiv.style.transition = ''; // Restore default transitions
                }
            }, 150); // Wait 150ms after last scroll event

        }, { passive: false });

        // Mouse events for desktop
        diagramContainer.addEventListener('mousedown', function(e) {
            // Only start panning on left mouse button and not on Mermaid interactive elements
            if (e.button === 0 && !e.target.closest('a, button, [onclick]')) {
                isPanning = true;
                startX = e.clientX - panX;
                startY = e.clientY - panY;
                lastPanX = panX;
                lastPanY = panY;

                diagramContainer.classList.add('panning');
                const diagramDiv = document.getElementById('mermaidDiagram');
                if (diagramDiv) {
                    diagramDiv.classList.add('no-transition');
                }

                e.preventDefault();
            }
        });

        document.addEventListener('mousemove', function(e) {
            if (isPanning) {
                panX = e.clientX - startX;
                panY = e.clientY - startY;
                constrainPan();
                applyZoom();
                e.preventDefault();
            }
        });

        document.addEventListener('mouseup', function(e) {
            if (isPanning) {
                isPanning = false;
                diagramContainer.classList.remove('panning');
                const diagramDiv = document.getElementById('mermaidDiagram');
                if (diagramDiv) {
                    diagramDiv.classList.remove('no-transition');
                }
            }
        });

        // Touch events for mobile devices
        diagramContainer.addEventListener('touchstart', function(e) {
            if (e.touches.length === 1 && !e.target.closest('a, button, [onclick]')) {
                isPanning = true;
                const touch = e.touches[0];
                startX = touch.clientX - panX;
                startY = touch.clientY - panY;
                lastPanX = panX;
                lastPanY = panY;

                diagramContainer.classList.add('panning');
                const diagramDiv = document.getElementById('mermaidDiagram');
                if (diagramDiv) {
                    diagramDiv.classList.add('no-transition');
                }

                e.preventDefault();
            }
        }, { passive: false });

        diagramContainer.addEventListener('touchmove', function(e) {
            if (isPanning && e.touches.length === 1) {
                const touch = e.touches[0];
                panX = touch.clientX - startX;
                panY = touch.clientY - startY;
                constrainPan();
                applyZoom();
                e.preventDefault();
            }
        }, { passive: false });

        diagramContainer.addEventListener('touchend', function(e) {
            if (isPanning) {
                isPanning = false;
                diagramContainer.classList.remove('panning');
                const diagramDiv = document.getElementById('mermaidDiagram');
                if (diagramDiv) {
                    diagramDiv.classList.remove('no-transition');
                }
            }
        });

        // Prevent context menu on right-click to avoid interference
        diagramContainer.addEventListener('contextmenu', function(e) {
            e.preventDefault();
        });

        // **Enhanced Features Logging**
        function logEnhancedFeatures() {
            console.log('üöÄ Enhanced Mermaid Viewer Features Loaded:');
            console.log('  ‚úÖ Enhanced Error Context - Line number detection, diagram type analysis');
            console.log('  ‚úÖ Performance Caching - AI response caching with cleanup');
            console.log('  ‚úÖ Progressive Enhancement - Offline syntax validation');
            console.log('  ‚ö° Quick Fix - Instant common pattern corrections');
            console.log('  ü§ñ AI Fix - Enhanced prompts with context');
            console.log('  üîß Structured Outputs - JSON Schema validation for AI responses');
            console.log('  üîÑ Fallback Support - Graceful degradation for unsupported models');
            console.log('  üìä Cache Stats:', getCacheStats());
        }

        // **Auto-render on input change**
        document.getElementById('mermaidInput').addEventListener('input', function() {
            // Debounce the rendering to avoid too frequent updates
            clearTimeout(this.renderTimeout);
            this.renderTimeout = setTimeout(() => {
                renderDiagram();
            }, 1000);
        });

        // **API Key Management**
        function saveApiKey() {
            const apiKey = document.getElementById('apiKeyInput').value.trim();
            if (apiKey) {
                localStorage.setItem('openrouter_api_key', apiKey);
            }
        }

        function loadApiKey() {
            const savedKey = localStorage.getItem('openrouter_api_key');
            if (savedKey) {
                document.getElementById('apiKeyInput').value = savedKey;
            }
        }

        // Save API key when user types
        document.getElementById('apiKeyInput').addEventListener('input', saveApiKey);

        // **Initial render**
        document.addEventListener('DOMContentLoaded', function() {
            loadApiKey(); // Load saved API key
            renderDiagram();
            logEnhancedFeatures(); // Log enhanced features
        });

        // **Keyboard shortcuts**
        document.addEventListener('keydown', function(e) {
            // Ctrl+Enter or Cmd+Enter to render
            if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') {
                e.preventDefault();
                renderDiagram();
            }

            // Ctrl+Shift+F or Cmd+Shift+F to format
            if ((e.ctrlKey || e.metaKey) && e.shiftKey && e.key === 'F') {
                e.preventDefault();
                formatCode();
            }

            // Arrow keys for panning (when not focused on input elements)
            if (!e.target.matches('input, textarea, select')) {
                switch(e.key) {
                    case 'ArrowLeft':
                        e.preventDefault();
                        panLeft();
                        break;
                    case 'ArrowRight':
                        e.preventDefault();
                        panRight();
                        break;
                    case 'ArrowUp':
                        e.preventDefault();
                        panUp();
                        break;
                    case 'ArrowDown':
                        e.preventDefault();
                        panDown();
                        break;
                    case 'Home':
                        e.preventDefault();
                        resetPan();
                        break;
                }
            }
        });
    </script>
</body>
</html>